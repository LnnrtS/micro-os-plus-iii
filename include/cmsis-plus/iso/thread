/*
 * This file is part of the µOS++ distribution.
 *   (https://github.com/micro-os-plus)
 * Copyright (c) 2016 Liviu Ionescu.
 *
 * µOS++ is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, version 3.
 *
 * µOS++ is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * This file is part of the CMSIS++ proposal, intended as a CMSIS
 * replacement for C++ applications.
 *
 * The code is inspired by LLVM libcxx and GNU libstdc++-v3.
 */

#ifndef CMSIS_PLUS_STD_THREAD_
#define CMSIS_PLUS_STD_THREAD_

// ----------------------------------------------------------------------------

#include <cmsis-plus/rtos/os.h>
#if defined(TRACE)
#include <cmsis-plus/diag/trace.h>
#endif
#include <cmsis-plus/iso/chrono>

#include <cstddef>
#include <iostream>
#include <type_traits>
#include <functional>

// ----------------------------------------------------------------------------

namespace os
{
  namespace estd
  {
    // ======================================================================

    class thread
    {
    public:

      using native_handle_type = os::rtos::Thread*;

      class id
      {
      public:
        id () noexcept;

        explicit
        id (native_handle_type system_thread) noexcept;

        ~id ();

      private:

        friend class thread;
#if 0
        friend class hash<thread::id>;
#endif

        // The id is actually a pointer to the system thread.
        native_handle_type native_thread_;

        // Only two of them, the other 4 are defined in terms of these.
        friend bool
        operator== (thread::id x, thread::id y) noexcept;

        friend bool
        operator< (thread::id x, thread::id y) noexcept;
      };

      thread () noexcept = default;

      template<
          typename Callable_T, //
          typename = typename ::std::enable_if<
              !::std::is_same<Callable_T, ::std::nullptr_t>::value>::type,
          typename ... Args_T>
        explicit
        thread (Callable_T&& f, Args_T&&... args);

      // CMSIS RTOS specific constructors (extension to the ISO standard),
      // used to create threads with POSIX custom attributes.

      template<
          typename Attr_T, //
          typename = typename ::std::enable_if<
              ::std::is_same<Attr_T, os::rtos::thread::Attributes>::value>::type,
          typename Callable_T, typename ... Args_T>
        explicit
        thread (Attr_T& attr, Callable_T&& f, Args_T&&... args);

      template<
          typename Attr_T, //
          typename = typename ::std::enable_if<
              ::std::is_same<Attr_T, os::rtos::thread::Attributes>::value>::type,
          typename Callable_T, typename ... Args_T>
        explicit
        thread (const Attr_T& attr, Callable_T&& f, Args_T&&... args);

      ~thread ();

      thread (const thread&) = delete;
      thread (thread&& t) noexcept;

      thread&
      operator= (const thread&) = delete;
      thread&
      operator= (thread&& t) noexcept;

      // --------------------------------------------------------------------

      void
      swap (thread& t) noexcept;

      bool
      joinable () const noexcept;

      void
      join ();

      void
      detach ();

      id
      get_id () const noexcept;

      native_handle_type
      native_handle ();

      static unsigned
      hardware_concurrency () noexcept;

    private:

      template<typename F_T>
        static void
        run_function_object (const void* func_object);

      template<typename F_T>
        static void
        delete_function_object (const void* func_obj);

      void
      delete_system_thread (void);

      // The current implementation creates temporary id() objects
      // and copies (moves?) them here.
      id id_;

      using function_object_deleter_t = void (*) (void*);
      function_object_deleter_t function_object_deleter_ = nullptr;

    public:

    };

    // ======================================================================

    void
    swap (thread& x, thread& y) noexcept;

    bool
    operator== (thread::id x, thread::id y) noexcept;
    bool
    operator!= (thread::id x, thread::id y) noexcept;
    bool
    operator< (thread::id x, thread::id y) noexcept;
    bool
    operator<= (thread::id x, thread::id y) noexcept;
    bool
    operator> (thread::id x, thread::id y) noexcept;
    bool
    operator>= (thread::id x, thread::id y) noexcept;

#if 0
    template<class charT, class traits>
    basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& out, thread::id id);
#endif

    // ======================================================================

    namespace this_thread
    {

      thread::id
      get_id () noexcept;

      void
      yield () noexcept;

      // The extra Clock_T is an extension to the standard
      template<typename Clock_T = chrono::Systick_clock, typename Rep_T,
          typename Period_T>
        constexpr void
        sleep_for (const ::std::chrono::duration<Rep_T, Period_T>& rel_time);

      template<typename Clock_T, typename Duration_T>
        void
        sleep_until (
            const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time);
    } /* namespace this_thread */

  } /* namespace estd */
} /* namespace os */

// ----------------------------------------------------------------------------
// Inline & template implementations.

namespace os
{
  namespace estd
  {
    // ======================================================================

    inline void
    swap (thread& x, thread& y) noexcept
    {
      x.swap (y);
    }

    inline bool
    operator== (thread::id x, thread::id y) noexcept
    {
      return x.native_thread_ == y.native_thread_;
    }

    inline bool
    operator!= (thread::id x, thread::id y) noexcept
    {
      return !(x == y);
    }

    inline bool
    operator< (thread::id x, thread::id y) noexcept
    {
      return x.native_thread_ < y.native_thread_;
    }

    inline bool
    operator<= (thread::id x, thread::id y) noexcept
    {
      return !(y < x);
    }

    inline bool
    operator> (thread::id x, thread::id y) noexcept
    {
      return y < x;
    }

    inline bool
    operator>= (thread::id x, thread::id y) noexcept
    {
      return !(x < y);
    }

    // ======================================================================

    inline
    thread::id::id () noexcept :
    native_thread_ ( nullptr)
      {
        ;
      }

    inline
    thread::id::id (native_handle_type native_thread) noexcept :
    native_thread_ ( native_thread)
      {
        ;
      }

    inline
    thread::id::~id ()
    {
      ;
    }

    // ----------------------------------------------------------------------

    inline thread::id
    thread::get_id () const noexcept
    {
      return id_;
    }

    inline thread::native_handle_type
    thread::native_handle ()
    {
      return id_.native_thread_;
    }

    inline unsigned
    thread::hardware_concurrency () noexcept
    {
      return 1;
    }

    template<typename F_T>
      void
      thread::run_function_object (const void* func_obj)
      {
        using Function_object = F_T;

        Function_object* f = (Function_object*) func_obj;
        (*f) ();
      }

    template<typename F_T>
      void
      thread::delete_function_object (const void* func_obj)
      {
        using Function_object = F_T;

        Function_object* f = (Function_object*) func_obj;

        os::trace::printf ("%s\n", __PRETTY_FUNCTION__);

        // The delete now has the knowledge required to
        // correctly delete the object (i.e. the object size).
        delete f;
      }

    template<typename Callable_T, typename T, typename ... Args_T>
      thread::thread (Callable_T&& f, Args_T&&... args) :
          thread (os::rtos::thread::initializer, ::std::forward<Callable_T> (f),
                  ::std::forward<Args_T>(args)...)
      {
        ;
      }

    template<typename Attr_T, typename T, typename Callable_T,
        typename ... Args_T>
      thread::thread (const Attr_T& attr, Callable_T&& f, Args_T&&... args) :
          thread ((Attr_T&) attr, ::std::forward<Callable_T> (f),
                  ::std::forward<Args_T>(args)...)
      {
        ;
      }

    template<typename Attr_T, typename T, typename Callable_T,
        typename ... Args_T>

      thread::thread (Attr_T& attr, Callable_T&& f, Args_T&&... args)
      {
        // static_assert(::std::is_same<Attr_T, os::rtos::thread::attr_t>::value, "first param must be thread_attr_t*");

        os::trace::printf ("%s(%p) @%p\n", __func__, &attr, this);

        using Function_object = decltype(::std::bind (::std::forward<Callable_T> (f),
                ::std::forward<Args_T>(args)...));

        // Dynamic allocation! The size depends on the number of arguments.
        // This creates a small problem, since both running the function
        // and deleting the object requires the type. It is passes as
        // template functions.
        Function_object* funct_obj = new Function_object (
            ::std::bind (::std::forward<Callable_T> (f),
                         ::std::forward<Args_T>(args)...));

        // The function to start the thread is a custom proxy that
        // knows how to get the variadic arguments.
        id_ = id
          { new os::rtos::Thread (
              attr,
              (os::rtos::thread::func_t) &run_function_object<Function_object>,
              (void*) funct_obj) };

        // The deleter, to be used during destruction.
        function_object_deleter_ =
            (function_object_deleter_t) &delete_function_object<Function_object>;
      }

    // ======================================================================

    namespace this_thread
    {

      /// yield
      inline void
      __attribute__((always_inline))
      yield () noexcept
      {
        os::rtos::this_thread::yield ();
      }

      inline thread::id
      get_id () noexcept
      {
        return thread::id (&os::rtos::this_thread::get ());
      }

      // This implementation currently supports only short
      // delays, since it uses the ticks timer.

      // Note: there is no absolute guarantee that the
      // sleep will not return earlier, so the application
      // might need to retry.

      // Note the constexpr return type, which tries to compute everything at
      // compile time. And, for constant durations, it succeeds.
#if 0
      template<class Rep_T, class Period_T>
      constexpr void
      sleep_for (const ::std::chrono::duration<Rep_T, Period_T>& rel_time)
        {
          using namespace ::std::chrono;

          if (rel_time > duration<Rep_T, Period_T>::zero ())
            {
              // Round up to micros, in case of nanos.
              microseconds micros =
              os::estd::chrono::ceil<microseconds> (rel_time);

              // Round up to ticks.
#if 0

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Waggregate-return"

              os::rtos::thread::sleep (
                  (os::rtos::systicks_t) (os::estd::chrono::ceil<
                      systicks> (micros).count ()));
#pragma GCC diagnostic pop

#else
              // The code seems better with this variant, otherwise it
              // does not optimise constant calls.
              os::rtos::Systick_clock::sleep_for (
                  os::rtos::Systick_clock::ticks_cast (
                      micros.count ()));
#endif

            }
        }
#endif

      template<typename Clock_T, class Rep_T, class Period_T>
        constexpr void
        sleep_for (const ::std::chrono::duration<Rep_T, Period_T>& rel_time)
        {
          using namespace ::std::chrono;

          using Clock = Clock_T;
          using sleep_rep = typename Clock::sleep_rep;

          if (rel_time > duration<Rep_T, Period_T>::zero ())
            {
              sleep_rep d = (sleep_rep) os::estd::chrono::ceil<
                  typename Clock::duration> (rel_time).count ();

              Clock::sleep_for (d);
            }
        }

      template<typename Clock_T, typename Duration_T>
        void
        sleep_until (
            const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time)
        {
          using Clock = Clock_T;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Waggregate-return"

          auto now = Clock::now ();

          while (now < abs_time)
            {
              sleep_for (abs_time - now);
              now = Clock::now ();
            }
        }

#pragma GCC diagnostic pop

      template<typename Duration_T>
        void
        sleep_until (
            const ::std::chrono::time_point<chrono::Realtime_clock, Duration_T>& abs_time)
        {
          using Clock = chrono::Realtime_clock;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Waggregate-return"

          auto now = Clock::now ();
          while (now < abs_time)
            {
              typename Clock::sleep_rep d = (os::estd::chrono::ceil<
                  typename Clock::sleep_duration> (abs_time - now)).count ();
              Clock::sleep_for (d);
              now = Clock::now ();
            }

#pragma GCC diagnostic pop

        }

      template<typename Duration_T>
        void
        sleep_until (
            const ::std::chrono::time_point<chrono::Systick_clock, Duration_T>& abs_time)
        {
          using Clock = chrono::Systick_clock;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Waggregate-return"

          auto now = Clock::now ();
          while (now < abs_time)
            {
              typename Clock::sleep_rep d = (os::estd::chrono::ceil<
                  typename Clock::sleep_duration> (abs_time - now)).count ();
              Clock::sleep_for (d);
              now = Clock::now ();
            }

#pragma GCC diagnostic pop

        }

    } /* namespace this_thread */

  // ------------------------------------------------------------------------

  } /* namespace estd */
} /* namespace os */

// ----------------------------------------------------------------------------

#endif /* CMSIS_PLUS_STD_THREAD_ */

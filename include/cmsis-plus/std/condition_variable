/*
 * This file is part of the µOS++ distribution.
 *   (https://github.com/micro-os-plus)
 * Copyright (c) 2016 Liviu Ionescu.
 *
 * µOS++ is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, version 3.
 *
 * µOS++ is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * This file is part of the CMSIS++ proposal, intended as a CMSIS
 * replacement for C++ applications.
 *
 * The code is inspired by LLVM libcxx and GNU libstdc++-v3.
 */

#ifndef CMSIS_PLUS_STD_CONDITION_VARIABLE_
#define CMSIS_PLUS_STD_CONDITION_VARIABLE_

#include <cmsis-plus/rtos/os.h>
#include <cmsis-plus/diag/trace.h>

#include <cmsis-plus/std/mutex>
//#include <memory>
#include <chrono>

namespace os
{
  namespace cmsis
  {
    namespace std
    {
      // ======================================================================

      enum class cv_status
      {
        no_timeout, //
        timeout
      };

      class condition_variable
      {
      private:

        using native_type = os::cmsis::rtos::Condition_variable;

      public:

        using native_handle_type = native_type*;

        condition_variable ();
        ~condition_variable ();

        condition_variable (const condition_variable&) = delete;
        condition_variable&
        operator= (const condition_variable&) = delete;

        void
        notify_one () noexcept;

        void
        notify_all () noexcept;

        void
        wait (unique_lock<mutex>& lock);

        template<class Predicate_T>
          void
          wait (unique_lock<mutex>& lock, Predicate_T pred);

        template<class Clock_T, class Duration_T>
          cv_status
          wait_until (
              unique_lock<mutex>& lock,
              const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time);

        template<class Clock_T, class Duration_T, class Predicate_T>
          bool
          wait_until (
              unique_lock<mutex>& lock,
              const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time,
              Predicate_T pred);

        template<class Rep_T, class Period_T>
          cv_status
          wait_for (unique_lock<mutex>& lock,
                    const ::std::chrono::duration<Rep_T, Period_T>& rel_time);

        template<class Rep_T, class Period_T, class Predicate_T>
          bool
          wait_for (unique_lock<mutex>& lock,
                    const ::std::chrono::duration<Rep_T, Period_T>& rel_time,
                    Predicate_T pred);

        native_handle_type
        native_handle ();

      protected:

        native_type ncv_;
      };

      void
      notify_all_at_thread_exit (condition_variable& cond,
                                 unique_lock<mutex> lk);

      class condition_variable_any
      {
      private:

        using native_type = os::cmsis::rtos::Condition_variable;

      public:

        using native_handle_type = native_type*;

        condition_variable_any ();

        ~condition_variable_any ();

        condition_variable_any (const condition_variable_any&) = delete;
        condition_variable_any&
        operator= (const condition_variable_any&) = delete;

        void
        notify_one () noexcept;

        void
        notify_all () noexcept;

        template<class Lock_T>
          void
          wait (Lock_T& lock);

        template<class Lock_T, class Predicate_T>
          void
          wait (Lock_T& lock, Predicate_T pred);

        template<class Lock_T, class Clock_T, class Duration_T>
          cv_status
          wait_until (
              Lock_T& lock,
              const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time);

        template<class Lock_T, class Clock_T, class Duration_T,
            class Predicate_T>
          bool
          wait_until (
              Lock_T& lock,
              const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time,
              Predicate_T pred);

        template<class Lock_T, class Rep_T, class Period_T>
          cv_status
          wait_for (Lock_T& lock,
                    const ::std::chrono::duration<Rep_T, Period_T>& rel_time);

        template<class Lock_T, class Rep_T, class Period_T, class Predicate_T>
          bool
          wait_for (Lock_T& lock,
                    const ::std::chrono::duration<Rep_T, Period_T>& rel_time,
                    Predicate_T pred);

      private:

        void
        __do_timed_wait (
            unique_lock<mutex>& __lk,
            ::std::chrono::time_point<::std::chrono::system_clock,
                ::std::chrono::nanoseconds>) noexcept;

      protected:

        native_type ncv_;

      };

    } /* namespace std */
  } /* namespace cmsis */
} /* namespace os */

// ============================================================================
// Inline & template implementations.

namespace os
{
  namespace cmsis
  {
    namespace std
    {
      // ======================================================================

      inline
      condition_variable::condition_variable ()
      {
      }

      inline
      condition_variable::~condition_variable ()
      {
      }

#if 0
      template<class _To, class Rep_T, class Period_T>
        inline typename enable_if<::std::chrono::__is_duration<_To>::value, _To>::type
        __ceil (::std::chrono::duration<Rep_T, Period_T> __d)
        {
          using namespace ::std::chrono;
          _To __r = ::std::chrono::duration_cast<_To> (__d);
          if (__r < __d)
            ++__r;
          return __r;
        }
#endif

      template<class Predicate_T>
        void
        condition_variable::wait (unique_lock<mutex>& lock, Predicate_T pred)
        {
          while (!pred ())
            wait (lock);
        }

      template<class Clock_T, class Duration_T>
        cv_status
        condition_variable::wait_until (
            unique_lock<mutex>& lock,
            const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time)
        {
          using namespace ::std::chrono;

          wait_for (lock, abs_time - Clock_T::now ());
          return
              Clock_T::now () < abs_time ?
                  cv_status::no_timeout : cv_status::timeout;
        }

      template<class Clock_T, class Duration_T, class Predicate_T>
        bool
        condition_variable::wait_until (
            unique_lock<mutex>& lock,
            const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time,
            Predicate_T pred)
        {
          while (!pred ())
            {
              if (wait_until (lock, abs_time) == cv_status::timeout)
                return pred ();
            }
          return true;
        }

      template<class Rep_T, class Period_T>
        cv_status
        condition_variable::wait_for (
            unique_lock<mutex>& lock,
            const ::std::chrono::duration<Rep_T, Period_T>& rel_time)
        {
          using namespace ::std::chrono;

          if (rel_time <= rel_time.zero ())
            {
              return cv_status::timeout;
            }
#if 0
          typedef time_point<system_clock, duration<long double, ::std::nano> > __sys_tpf;
          typedef time_point<system_clock, nanoseconds> __sys_tpi;
          __sys_tpf _Max = __sys_tpi::max ();
          system_clock::time_point __s_now = system_clock::now ();
#endif
          steady_clock::time_point __c_now = steady_clock::now ();
#if 0
          if (_Max - rel_time > __s_now)
            {
              __do_timed_wait (lock, __s_now + __ceil<nanoseconds> (rel_time));
            }
          else
            {
              __do_timed_wait (lock, __sys_tpi::max ());
            }
#endif
          return
              steady_clock::now () - __c_now < rel_time ?
                  cv_status::no_timeout : cv_status::timeout;
        }

      template<class Rep_T, class Period_T, class Predicate_T>
        inline
        bool
        condition_variable::wait_for (
            unique_lock<mutex>& lock,
            const ::std::chrono::duration<Rep_T, Period_T>& rel_time,
            Predicate_T pred)
        {
          return wait_until (lock,
                             ::std::chrono::steady_clock::now () + rel_time,
                             ::std::move (pred));
        }

    } /* namespace std */
  } /* namespace cmsis */
} /* namespace os */

#endif /* CMSIS_PLUS_STD_CONDITION_VARIABLE_ */

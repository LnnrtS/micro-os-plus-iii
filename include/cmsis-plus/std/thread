/*
 * This file is part of the µOS++ distribution.
 *   (https://github.com/micro-os-plus)
 * Copyright (c) 2016 Liviu Ionescu.
 *
 * µOS++ is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, version 3.
 *
 * µOS++ is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * This file is part of the CMSIS++ proposal, intended as a CMSIS
 * replacement for C++ applications.
 *
 * The code is inspired by LLVM libcxx and GNU libstdc++-v3.
 */

#ifndef CMSIS_PLUS_STD_THREAD_
#define CMSIS_PLUS_STD_THREAD_

// ----------------------------------------------------------------------------

#include <cmsis-plus/rtos/os.h>
#if defined(TRACE)
#include <cmsis-plus/diag/trace.h>
#endif

#include <cstddef>
#include <chrono>
#include <iostream>
#include <type_traits>
// #include <memory>

// ----------------------------------------------------------------------------

namespace os
{
  namespace cmsis
  {
    namespace std
    {
      // ======================================================================

      class thread
      {
      public:

        class id;

        using native_handle_type = os::cmsis::rtos::Thread*;

        thread () noexcept = default;

        template<typename Callable_T, typename ... Args_T>
          explicit
          thread (Callable_T&& f, Args_T&&... args);

        // CMSIS RTOS specific constructors (extension to the ISO standard),
        // used to create threads with name and custom stack.

        thread (native_handle_type native) noexcept;

#if 0
        // This is a very generic template, intentionally not implemented
        // as is, but only for "const char*" & "size_t".
        template<typename N_T,//
        //typename ::std::enable_if<::std::is_same<N_T, const char>::value>::type, //
        //typename ::std::enable_if<::std::is_same<void, const char>::value>::type, //
        //typename ::std::enable_if<true>::type* = nullptr, // ok
        // typename ::std::enable_if<::std::is_same<void, void>::value>::type* = nullptr, // ok
        //typename ::std::enable_if<::std::is_same<N_T, const char>::value>::type* = nullptr, // ok
        typename ::std::enable_if<::std::is_same<N_T, char>::value>::type* =
        nullptr,// ok
//            typename ::std::enable_if<
//                ::std::is_same<::std::remove_const<N_T>::type, char>::value>::type* =
//                nullptr, // not ok
        typename SZ_T,//
        typename Callable_T, typename ... Args_T>
        explicit
        thread (N_T* name, SZ_T stack_size_bytes, Callable_T&& f,
            Args_T&&... args)
          {
            os::cmsis::trace::printf ("%s(\"%s\", %d) @%p \n", __func__, name,
                stack_size_bytes, this);
            id_ = id
              { new os::cmsis::rtos::Thread (name,
                    (::std::size_t) stack_size_bytes,
                    os::cmsis::rtos::Priority::normal,
                    ::std::forward<Callable_T> (f),
                    ::std::forward<Args_T>(args)...)};
          }
#endif

        ~thread ();

        thread (const thread&) = delete;
        thread (thread&& t) noexcept;

        thread&
        operator= (const thread&) = delete;
        thread&
        operator= (thread&& t) noexcept;

        // --------------------------------------------------------------------

        void
        swap (thread& t) noexcept;

        bool
        joinable () const noexcept;

        void
        join ();

        void
        detach ();

        id
        get_id () const noexcept;

        native_handle_type
        native_handle ();

        static unsigned
        hardware_concurrency () noexcept;

        class id
        {
        public:
          id () noexcept;

          explicit
          id (native_handle_type system_thread) noexcept;

          ~id ();

        private:

          friend class thread;
#if 0
          friend class hash<thread::id>;
#endif

          // The id is actually a pointer to the system thread.
          native_handle_type system_thread_;

          // Only two of them, the other 4 are defined in terms of these.
          friend bool
          operator== (thread::id x, thread::id y) noexcept;

          friend bool
          operator< (thread::id x, thread::id y) noexcept;
        };

      private:

        // The current implementation creates lots of temporary id() objects
        // and copies them here. Probably a better strategy would be to
        // move them, this would allow the use of a smart pointer to
        // automatically delete the system thread.
        id id_;
      };

      // ======================================================================

      void
      swap (thread& x, thread& y) noexcept;

      bool
      operator== (thread::id x, thread::id y) noexcept;
      bool
      operator!= (thread::id x, thread::id y) noexcept;
      bool
      operator< (thread::id x, thread::id y) noexcept;
      bool
      operator<= (thread::id x, thread::id y) noexcept;
      bool
      operator> (thread::id x, thread::id y) noexcept;
      bool
      operator>= (thread::id x, thread::id y) noexcept;

#if 0
      template<class charT, class traits>
      basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& out, thread::id id);
#endif

      // ======================================================================

      namespace this_thread
      {

        thread::id
        get_id () noexcept;

        void
        yield () noexcept;

        template<typename Clock_T, typename Duration_T>
          void
          sleep_until (
              const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time);

        template<typename Rep_T, typename Period_T>
          constexpr void
          sleep_for (const ::std::chrono::duration<Rep_T, Period_T>& rel_time);

      } /* namespace this_thread */

    } /* namespace std */
  } /* namespace cmsis */
} /* namespace os */

// ----------------------------------------------------------------------------
// Inline & template implementations.

namespace os
{
  namespace cmsis
  {
    namespace std
    {
      // ======================================================================

      inline void
      swap (thread& x, thread& y) noexcept
      {
        x.swap (y);
      }

      inline bool
      operator== (thread::id x, thread::id y) noexcept
      {
        return x.system_thread_ == y.system_thread_;
      }

      inline bool
      operator!= (thread::id x, thread::id y) noexcept
      {
        return !(x == y);
      }

      inline bool
      operator< (thread::id x, thread::id y) noexcept
      {
        return x.system_thread_ < y.system_thread_;
      }

      inline bool
      operator<= (thread::id x, thread::id y) noexcept
      {
        return !(y < x);
      }

      inline bool
      operator> (thread::id x, thread::id y) noexcept
      {
        return y < x;
      }

      inline bool
      operator>= (thread::id x, thread::id y) noexcept
      {
        return !(x < y);
      }

      // ----------------------------------------------------------------------

      inline thread::id
      thread::get_id () const noexcept
      {
        return id_;
      }

      inline thread::native_handle_type
      thread::native_handle ()
      {
        return id_.system_thread_;
      }

      inline unsigned
      thread::hardware_concurrency () noexcept
      {
        return 1;
      }

      template<typename Callable_T, typename ... Args_T>
        thread::thread (Callable_T&& f, Args_T&&... args)
        {
          os::cmsis::trace::printf ("%s() @%p\n", __func__, this);
          id_ = id
            { new os::cmsis::rtos::Thread (nullptr, 0,
                                           os::cmsis::rtos::Priority::normal,
                                           ::std::forward<Callable_T> (f),
                                           ::std::forward<Args_T>(args)...) };
        }

      inline
      thread::thread (native_handle_type native) noexcept
      {
        id_ = id
          { native };
      }

#if 0
      // Implement only a specialised version of this template.
      template<typename N_T /*= char */, typename SZ_T /*= ::std::size_t*/,
      typename Callable_T, typename ... Args_T>
      thread::thread (N_T* name, SZ_T stack_size_bytes, Callable_T&& f,
          Args_T&&... args)
        {
          os::cmsis::trace::printf ("%s(\"%s\", %d) @%p \n", __func__, name,
              stack_size_bytes, this);
          id_ = id
            { new os::cmsis::rtos::Thread (name,
                  (::std::size_t) stack_size_bytes,
                  os::cmsis::rtos::Priority::normal,
                  ::std::forward<Callable_T> (f),
                  ::std::forward<Args_T>(args)...)};
        }
#endif

      // ----------------------------------------------------------------------

      inline
      thread::id::id () noexcept :
      system_thread_ ( nullptr)
        {
          ;
        }

      inline
      thread::id::id (native_handle_type system_thread) noexcept :
      system_thread_ ( system_thread)
        {
          ;
        }

      inline
      thread::id::~id ()
      {
        ;
      }

      // ----------------------------------------------------------------------

      namespace this_thread
      {

        /// yield
        inline void
        yield () noexcept
        {
          os::cmsis::rtos::thread::yield ();
        }

        inline thread::id
        get_id () noexcept
        {
          return thread::id (&os::cmsis::rtos::thread::get_current ());
        }

        // Note: there is no absolute guarantee that the
        // sleep will not return earlier, so the application
        // might need to retry.

        // Note the constexpr return type, which tries to compute everything at
        // compile time. And, for constant durations, it succeeds.
        // However, due to an odd behaviour, if there are calls with
        // non-constant arguments, they are used always.
        template<class Rep_T, class Period_T>
          constexpr void
          sleep_for (const ::std::chrono::duration<Rep_T, Period_T>& rel_time)
          {
            using namespace ::std::chrono;

            if (rel_time > duration<Rep_T, Period_T>::zero ())
              {
                microseconds micros = microseconds::zero();
                if (rel_time < microseconds::max ())
                  {
                    micros = duration_cast<microseconds> (rel_time);
                    if (micros < rel_time)
                      {
                        ++micros;
                      }
                  }
                else
                  {
                    micros = microseconds::max ();
                  }

                // The RTOS can sleep only for ticks, so convert
                // micros to ticks.
                os::cmsis::rtos::thread::sleep (
                    os::cmsis::rtos::kernel::compute_sys_ticks (
                        micros.count ()));

              }
          }
      }

      template<typename Clock_T, typename Duration_T>
        inline void
        sleep_until (
            const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time)
        {
          using Clock = Clock_T;

          auto now = Clock::now ();
#if 0
          if (Clock::is_steady)
            {
              // In the GCC implementation,
              // steady clocks are trustworthy, one sleep is enough.
              if (now < abs_time)
                {
                  sleep_for (abs_time - now);
                }
              return;
            }
#endif
          while (now < abs_time)
            {
              sleep_for (abs_time - now);
              now = Clock::now ();
            }
        }

    } /* namespace std */
  } /* namespace cmsis */
} /* namespace os */

// ----------------------------------------------------------------------------

#endif /* CMSIS_PLUS_STD_THREAD_ */

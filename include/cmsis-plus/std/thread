/*
 * This file is part of the µOS++ distribution.
 *   (https://github.com/micro-os-plus)
 * Copyright (c) 2016 Liviu Ionescu.
 *
 * µOS++ is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, version 3.
 *
 * µOS++ is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * This file is part of the CMSIS++ proposal, intended as a CMSIS
 * replacement for C++ applications.
 *
 * The code is inspired by LLVM libcxx and GNU libstdc++-v3.
 */

#ifndef CMSIS_PLUS_STD_THREAD_
#define CMSIS_PLUS_STD_THREAD_

// ----------------------------------------------------------------------------

#include <cmsis-plus/rtos/os.h>
#if defined(TRACE)
#include <cmsis-plus/diag/trace.h>
#endif

#include <cstddef>
#include <chrono>
#include <iostream>
#include <type_traits>
#include <functional>

// ----------------------------------------------------------------------------

namespace os
{
  namespace cmsis
  {
    namespace std
    {
      // ======================================================================

      class thread
      {
      public:

        using native_handle_type = os::cmsis::rtos::Thread*;

        class id
        {
        public:
          id () noexcept;

          explicit
          id (native_handle_type system_thread) noexcept;

          ~id ();

        private:

          friend class thread;
#if 0
          friend class hash<thread::id>;
#endif

          // The id is actually a pointer to the system thread.
          native_handle_type system_thread_;

          // Only two of them, the other 4 are defined in terms of these.
          friend bool
          operator== (thread::id x, thread::id y) noexcept;

          friend bool
          operator< (thread::id x, thread::id y) noexcept;
        };

        thread () noexcept = default;

        template<
            typename Callable_T, //
            typename = typename ::std::enable_if<
                !::std::is_same<Callable_T, ::std::nullptr_t>::value>::type,
            typename ... Args_T>
          explicit
          thread (Callable_T&& f, Args_T&&... args);

        // CMSIS RTOS specific constructors (extension to the ISO standard),
        // used to create threads with POSIX custom attributes.

        template<
            typename Attr_T, //
            typename = typename ::std::enable_if<
                ::std::is_same<Attr_T, os::cmsis::rtos::thread::Attributes>::value>::type,
            typename Callable_T, typename ... Args_T>
          explicit
          thread (Attr_T& attr, Callable_T&& f, Args_T&&... args);

        template<
            typename Attr_T, //
            typename = typename ::std::enable_if<
                ::std::is_same<Attr_T, os::cmsis::rtos::thread::Attributes>::value>::type,
            typename Callable_T, typename ... Args_T>
          explicit
          thread (const Attr_T& attr, Callable_T&& f, Args_T&&... args);

        ~thread ();

        thread (const thread&) = delete;
        thread (thread&& t) noexcept;

        thread&
        operator= (const thread&) = delete;
        thread&
        operator= (thread&& t) noexcept;

        // --------------------------------------------------------------------

        void
        swap (thread& t) noexcept;

        bool
        joinable () const noexcept;

        void
        join ();

        void
        detach ();

        id
        get_id () const noexcept;

        native_handle_type
        native_handle ();

        static unsigned
        hardware_concurrency () noexcept;

      private:

        template<typename F_T>
          static void
          run_function_object (const void* func_object);

        template<typename F_T>
          static void
          delete_function_object (const void* func_obj);

        void
        delete_system_thread (void);

        // The current implementation creates lots of temporary id() objects
        // and copies (moves?) them here.
        id id_;

        using function_object_deleter_t = void (*) (void*);
        function_object_deleter_t function_object_deleter_ = nullptr;

      public:

      };

      // ======================================================================

      void
      swap (thread& x, thread& y) noexcept;

      bool
      operator== (thread::id x, thread::id y) noexcept;
      bool
      operator!= (thread::id x, thread::id y) noexcept;
      bool
      operator< (thread::id x, thread::id y) noexcept;
      bool
      operator<= (thread::id x, thread::id y) noexcept;
      bool
      operator> (thread::id x, thread::id y) noexcept;
      bool
      operator>= (thread::id x, thread::id y) noexcept;

#if 0
      template<class charT, class traits>
      basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& out, thread::id id);
#endif

      // ======================================================================

      namespace this_thread
      {

        thread::id
        get_id () noexcept;

        void
        yield () noexcept;

        template<typename Clock_T, typename Duration_T>
          void
          sleep_until (
              const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time);

        template<typename Rep_T, typename Period_T>
          constexpr void
          sleep_for (const ::std::chrono::duration<Rep_T, Period_T>& rel_time);

      } /* namespace this_thread */

    } /* namespace std */
  } /* namespace cmsis */
} /* namespace os */

// ----------------------------------------------------------------------------
// Inline & template implementations.

namespace os
{
  namespace cmsis
  {
    namespace std
    {
      // ======================================================================

      inline void
      swap (thread& x, thread& y) noexcept
      {
        x.swap (y);
      }

      inline bool
      operator== (thread::id x, thread::id y) noexcept
      {
        return x.system_thread_ == y.system_thread_;
      }

      inline bool
      operator!= (thread::id x, thread::id y) noexcept
      {
        return !(x == y);
      }

      inline bool
      operator< (thread::id x, thread::id y) noexcept
      {
        return x.system_thread_ < y.system_thread_;
      }

      inline bool
      operator<= (thread::id x, thread::id y) noexcept
      {
        return !(y < x);
      }

      inline bool
      operator> (thread::id x, thread::id y) noexcept
      {
        return y < x;
      }

      inline bool
      operator>= (thread::id x, thread::id y) noexcept
      {
        return !(x < y);
      }

      // ======================================================================

      inline
      thread::id::id () noexcept :
      system_thread_ ( nullptr)
        {
          ;
        }

      inline
      thread::id::id (native_handle_type system_thread) noexcept :
      system_thread_ ( system_thread)
        {
          ;
        }

      inline
      thread::id::~id ()
      {
        ;
      }

      // ----------------------------------------------------------------------

      inline thread::id
      thread::get_id () const noexcept
      {
        return id_;
      }

      inline thread::native_handle_type
      thread::native_handle ()
      {
        return id_.system_thread_;
      }

      inline unsigned
      thread::hardware_concurrency () noexcept
      {
        return 1;
      }

      template<typename F_T>
        void
        thread::run_function_object (const void* func_obj)
        {
          using Function_object = F_T;

          Function_object* f = (Function_object*) func_obj;
          (*f) ();
        }

      template<typename F_T>
        void
        thread::delete_function_object (const void* func_obj)
        {
          using Function_object = F_T;

          Function_object* f = (Function_object*) func_obj;

          os::cmsis::trace::printf ("%s\n", __PRETTY_FUNCTION__);

          // The delete now has the knowledge required to
          // correctly delete the object (i.e. the object size).
          delete f;
        }

      template<typename Callable_T, typename T, typename ... Args_T>
        thread::thread (Callable_T&& f, Args_T&&... args) :
            thread (os::cmsis::rtos::thread::initializer,
                    ::std::forward<Callable_T> (f),
                    ::std::forward<Args_T>(args)...)
        {
          ;
        }

      template<typename Attr_T, typename T, typename Callable_T,
          typename ... Args_T>
        thread::thread (const Attr_T& attr, Callable_T&& f, Args_T&&... args) :
            thread ((Attr_T&) attr, ::std::forward<Callable_T> (f),
                    ::std::forward<Args_T>(args)...)
        {
          ;
        }

      template<typename Attr_T, typename T, typename Callable_T,
          typename ... Args_T>

        thread::thread (Attr_T& attr, Callable_T&& f, Args_T&&... args)
        {
          // static_assert(::std::is_same<Attr_T, os::cmsis::rtos::thread::attr_t>::value, "first param must be thread_attr_t*");

          os::cmsis::trace::printf ("%s(%p) @%p\n", __func__, &attr, this);

          using Function_object = decltype(::std::bind (::std::forward<Callable_T> (f),
                  ::std::forward<Args_T>(args)...));

          // Dynamic allocation! The size depends on the number of arguments.
          // This creates a small problem, since both running the function
          // and deleting the object requires the type. It is passes as
          // template functions.
          Function_object* funct_obj = new Function_object (
              ::std::bind (::std::forward<Callable_T> (f),
                           ::std::forward<Args_T>(args)...));

          // The function to start the thread is a custom proxy that
          // knows how to get the variadic arguments.
          id_ = id
            { new os::cmsis::rtos::Thread (
                attr,
                (os::cmsis::rtos::thread::func_t) &run_function_object<
                    Function_object>,
                (void*) funct_obj) };

          // The deleter, to be used during destruction.
          function_object_deleter_ =
              (function_object_deleter_t) &delete_function_object<
                  Function_object>;
        }

      // ======================================================================

      namespace this_thread
      {

        /// yield
        inline void
        yield () noexcept
        {
          os::cmsis::rtos::thread::yield ();
        }

        inline thread::id
        get_id () noexcept
        {
          return thread::id (&os::cmsis::rtos::thread::get_current ());
        }

        // Note: there is no absolute guarantee that the
        // sleep will not return earlier, so the application
        // might need to retry.

        // Note the constexpr return type, which tries to compute everything at
        // compile time. And, for constant durations, it succeeds.
        // However, due to an odd behaviour, if there are calls with
        // non-constant arguments, they are used always.
        template<class Rep_T, class Period_T>
          constexpr void
          sleep_for (const ::std::chrono::duration<Rep_T, Period_T>& rel_time)
          {
            using namespace ::std::chrono;

            if (rel_time > duration<Rep_T, Period_T>::zero ())
              {
                microseconds micros = microseconds::zero ();
                if (rel_time < microseconds::max ())
                  {
                    micros = duration_cast<microseconds> (rel_time);
                    if (micros < rel_time)
                      {
                        ++micros;
                      }
                  }
                else
                  {
                    micros = microseconds::max ();
                  }

                // The RTOS can sleep only for ticks, so convert
                // micros to ticks.
                os::cmsis::rtos::thread::sleep (
                    os::cmsis::rtos::kernel::compute_sys_ticks (
                        micros.count ()));

              }
          }
      }

      template<typename Clock_T, typename Duration_T>
        inline void
        sleep_until (
            const ::std::chrono::time_point<Clock_T, Duration_T>& abs_time)
        {
          using Clock = Clock_T;

          auto now = Clock::now ();
#if 0
          if (Clock::is_steady)
            {
              // In the GCC implementation,
              // steady clocks are trustworthy, one sleep is enough.
              if (now < abs_time)
                {
                  sleep_for (abs_time - now);
                }
              return;
            }
#endif
          while (now < abs_time)
            {
              sleep_for (abs_time - now);
              now = Clock::now ();
            }
        }

    } /* namespace std */
  } /* namespace cmsis */
} /* namespace os */

// ----------------------------------------------------------------------------

#endif /* CMSIS_PLUS_STD_THREAD_ */
